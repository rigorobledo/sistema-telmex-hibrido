"""
Dashboard Unificado - Sistema S√≠ncrono + As√≠ncrono
=================================================

Interfaz que combina ambos sistemas y permite elegir el modo de procesamiento.
"""

import streamlit as st
import pandas as pd
import time
from datetime import datetime
import sys
import os

import time
from datetime import datetime

# Importar componentes del sistema as√≠ncrono
try:
    from async_processor.config import AsyncConfig
    from async_processor.utils import AsyncUtils
    from async_processor.core import AsyncProcessor
except ImportError:
    try:
        from config import AsyncConfig
        from utils import AsyncUtils  
        from core import AsyncProcessor
    except ImportError:
        import sys
        import os
        sys.path.append(os.path.dirname(__file__))
        from config import AsyncConfig
        from utils import AsyncUtils
        from core import AsyncProcessor

class UnifiedDashboard:
    """Dashboard que une sistema s√≠ncrono y as√≠ncrono"""
    
    def __init__(self):
        self.async_processor = None
        self.initialize_processors()

    def read_csv_smart_encoding(self, uploaded_file):
        """Leer CSV con detecci√≥n autom√°tica de encoding"""
        
        # Lista de encodings comunes en M√©xico/Am√©rica Latina
        encodings_to_try = [
            'utf-8',           # Est√°ndar
            'latin-1',         # ISO-8859-1 (muy com√∫n)
            'cp1252',          # Windows-1252 (Excel en Windows)
            'iso-8859-1',      # Otra variante de latin
            'utf-8-sig',       # UTF-8 con BOM
            'cp850',           # DOS Am√©rica Latina
            'ascii'            # Fallback b√°sico
        ]
        
        # Resetear el archivo para poder leerlo m√∫ltiples veces
        uploaded_file.seek(0)
        file_content = uploaded_file.read()
        
        for encoding in encodings_to_try:
            try:
                # Intentar decodificar el contenido
                content_str = file_content.decode(encoding)
                
                # Crear un objeto StringIO para pandas
                from io import StringIO
                content_io = StringIO(content_str)
                
                # Intentar leer con pandas
                df = pd.read_csv(content_io)
                
                # Si llegamos aqu√≠, funcion√≥
                st.success(f"‚úÖ Archivo le√≠do exitosamente (encoding: {encoding})")
                
                # Validar que tenga contenido
                if df.empty:
                    st.error("‚ùå El archivo est√° vac√≠o")
                    return None
                
                # Mostrar informaci√≥n b√°sica del archivo
                st.info(f"""
                **üìã Informaci√≥n del archivo:**
                - **Filas:** {len(df):,}
                - **Columnas:** {len(df.columns)}
                - **Encoding detectado:** {encoding}
                - **Columnas encontradas:** {', '.join(df.columns[:5])}{'...' if len(df.columns) > 5 else ''}
                """)
                
                return df
                
            except (UnicodeDecodeError, pd.errors.EmptyDataError, pd.errors.ParserError) as e:
                # Intentar siguiente encoding
                continue
            except Exception as e:
                # Error diferente, reportar pero continuar
                print(f"Error con encoding {encoding}: {e}")
                continue
        
        # Si ning√∫n encoding funcion√≥
        st.error("‚ùå No se pudo leer el archivo con ning√∫n encoding com√∫n")
        
        # Mostrar informaci√≥n de ayuda
        with st.expander("üí° Sugerencias para solucionar"):
            st.markdown("""
            **Posibles soluciones:**
            
            1. **Guardar archivo en UTF-8:**
            - Abre el archivo en Excel
            - File ‚Üí Save As ‚Üí CSV UTF-8 (Comma delimited)
            
            2. **Usar Notepad++:**
            - Abre el archivo en Notepad++
            - Encoding ‚Üí Convert to UTF-8
            - Guardar
            
            3. **Verificar el archivo:**
            - Aseg√∫rate de que sea un CSV v√°lido
            - Primera fila debe tener los nombres de columnas
            - Separado por comas
            
            **Encodings intentados:**
            {}
            """.format(", ".join(encodings_to_try)))
        
        return None
    
    def initialize_processors(self):
        """Inicializar procesadores"""
        try:
            # Inicializar procesador as√≠ncrono
            if 'async_processor' not in st.session_state:
                st.session_state.async_processor = AsyncProcessor()
                st.session_state.async_processor.start_workers()
            
            self.async_processor = st.session_state.async_processor
            
        except Exception as e:
            st.error(f"Error inicializando procesadores: {e}")
    
    def show_main_interface(self):
        """Mostrar interfaz principal unificada"""
    
        st.markdown("## üöÄ Sistema de Procesamiento Unificado")
        
        # Mostrar configuraci√≥n actual
        self.show_current_config()
        
        # Crear tabs
        tab1, tab2, tab3, tab4 = st.tabs([
            "üì§ Subir Archivos", 
            "üìä Monitoreo As√≠ncrono", 
            "üìã Mis Tareas", 
            "‚öôÔ∏è Configuraci√≥n"
        ])
        
        with tab1:
            self.show_file_upload_interface("_tab1")  # ‚Üê SUFIJO √öNICO
        
        with tab2:
            self.show_async_monitoring()
        
        with tab3:
            self.show_user_tasks()
        
        with tab4:
            self.show_async_configuration()
    
    def show_current_config(self):
        """Mostrar configuraci√≥n actual del sistema"""
        
        env = AsyncUtils.detect_environment()
        
        col1, col2, col3, col4 = st.columns(4)
        
        with col1:
            st.metric(
                "Ambiente", 
                env['environment_name'],
                help="Local = tu PC, Railway = producci√≥n"
            )
        
        with col2:
            st.metric(
                "Umbral As√≠ncrono", 
                f"{AsyncConfig.AUTO_ASYNC_THRESHOLD:,}",
                help="Registros m√≠nimos para activar modo as√≠ncrono"
            )
        
        with col3:
            if self.async_processor:
                stats = self.async_processor.get_system_stats()
                st.metric(
                    "Workers Activos", 
                    f"{stats['workers_active']}/{stats['workers_max']}",
                    help="Trabajadores procesando tareas"
                )
            else:
                st.metric("Workers Activos", "0/0")
        
        with col4:
            # Obtener rol del usuario actual
            usuario_actual = st.session_state.get('usuario_actual', {})
            rol = usuario_actual.get('rol', 'USUARIO')
            limits = AsyncUtils.get_user_limits(rol)
            
            st.metric(
                "L√≠mite de Archivos", 
                "‚àû" if limits['max_files_in_queue'] == -1 else limits['max_files_in_queue'],
                help=f"Archivos m√°ximos en cola para rol {rol}"
            )
    
    def show_file_upload_interface(self, form_suffix=""):
        """Interfaz mejorada para subir archivos"""
    
        st.markdown("### üì§ Subir y Procesar Archivos")
        
        # Obtener informaci√≥n del usuario
        usuario_actual = st.session_state.get('usuario_actual', {})
        if not usuario_actual:
            st.error("‚ùå No hay usuario autenticado")
            return
        
        user_id = usuario_actual.get('id_usuario', 'unknown')
        user_role = usuario_actual.get('rol', 'USUARIO')
        
        # Mostrar l√≠mites del usuario
        limits = AsyncUtils.get_user_limits(user_role)
        
        st.info(f"""
        **üë§ L√≠mites para rol {user_role}:**
        - üìÅ Archivos en cola: {'Ilimitados' if limits['max_files_in_queue'] == -1 else limits['max_files_in_queue']}
        - üìä Registros por archivo: {'Ilimitados' if limits['max_records_per_file'] == -1 else f"{limits['max_records_per_file']:,}"}
        - ‚≠ê Prioridad: {'Alta' if limits['priority'] == 3 else 'Media' if limits['priority'] == 2 else 'Normal'}
        """)
        
        # PASO 1: FORMULARIO SOLO PARA UPLOAD (SIN BOTONES DE PROCESAMIENTO)
        form_key = f"async_upload_form{form_suffix}"
        with st.form(form_key, clear_on_submit=False):
            col1, col2 = st.columns(2)
            
            with col1:
                tipo_catalogo = st.selectbox(
                    "Tipo de Cat√°logo:",
                    ["-- Seleccionar --", "ESTADOS", "MUNICIPIOS", "CIUDADES", "COLONIAS", "ALCALDIAS"],
                    help="Tipo de datos que vas a procesar"
                )
            
            with col2:
                division = st.selectbox(
                    "Divisi√≥n:",
                    ["-- Seleccionar --", "DES", "QAS", "MEX", "GDL", "MTY", "NTE", "TIJ"],
                    help="Divisi√≥n a la que pertenecen los datos"
                )
            
            # Upload del archivo
            uploaded_file = st.file_uploader(
                "üìÅ Selecciona archivo CSV:",
                type=['csv'],
                help="Archivo con estructura AS400 v√°lida"
            )
            
            # √öNICO BOT√ìN EN EL FORM: ANALIZAR
            submitted = st.form_submit_button("üîç Analizar Archivo", type="primary")
        
        # PASO 2: PROCESAMIENTO FUERA DEL FORM
        if submitted and uploaded_file and tipo_catalogo != "-- Seleccionar --" and division != "-- Seleccionar --":
            # Guardar datos para procesamiento
            st.session_state.file_ready_for_processing = {
                'file': uploaded_file,
                'tipo_catalogo': tipo_catalogo,
                'division': division,
                'user_id': user_id,
                'user_role': user_role,
                'timestamp': time.time()
            }
            st.rerun()  # Refrescar para mostrar opciones
        
        elif submitted:
            st.warning("‚ö†Ô∏è Por favor, completa todos los campos y selecciona un archivo")
        
        # PASO 3: MOSTRAR OPCIONES DE PROCESAMIENTO SI HAY ARCHIVO LISTO
        if 'file_ready_for_processing' in st.session_state:
            file_data = st.session_state.file_ready_for_processing
            
            # Verificar que no sea muy viejo (5 minutos)
            if time.time() - file_data['timestamp'] > 300:
                del st.session_state.file_ready_for_processing
                st.warning("‚è±Ô∏è Sesi√≥n expirada. Sube el archivo nuevamente.")
                return
            
            self.show_processing_options(file_data)

    def show_processing_options(self, file_data):
        """Mostrar opciones de procesamiento FUERA del formulario"""
        
        st.markdown("---")
        st.markdown("### üìä Archivo Analizado")
        
        try:
            # Leer archivo
            uploaded_file = file_data['file']
            df = self.read_csv_smart_encoding(uploaded_file)
            
            if df is None:
                # Limpiar datos si hay error
                del st.session_state.file_ready_for_processing
                return
            
            num_records = len(df)
            tipo_catalogo = file_data['tipo_catalogo']
            
            # Mostrar informaci√≥n del archivo
            col1, col2, col3 = st.columns(3)
            
            with col1:
                st.metric("üìä Registros", f"{num_records:,}")
            
            with col2:
                estimated_time = AsyncUtils.estimate_processing_time(num_records, tipo_catalogo)
                st.metric("‚è±Ô∏è Tiempo Estimado", AsyncUtils.format_duration(estimated_time))
            
            with col3:
                # Determinar modo recomendado
                if num_records >= AsyncConfig.AUTO_ASYNC_THRESHOLD:
                    modo_recomendado = "üîÑ As√≠ncrono"
                    color = "üü¢"
                else:
                    modo_recomendado = "‚ö° S√≠ncrono"
                    color = "üîµ"
                
                st.metric("üéØ Modo Recomendado", f"{color} {modo_recomendado}")
            
            # OPCIONES DE PROCESAMIENTO (FUERA DEL FORM)
            st.markdown("### üöÄ Selecciona Modo de Procesamiento")
            
            col1, col2, col3 = st.columns([2, 2, 1])
            
            with col1:
                if st.button("‚ö° PROCESAR S√çNCRONO", type="secondary", use_container_width=True):
                    self.process_sync(df, file_data)
            
            with col2:
                # Validar si puede usar as√≠ncrono
                can_async, async_message = AsyncUtils.validate_file_for_async(df, tipo_catalogo, file_data['user_role'])
                
                if can_async:
                    if st.button("üîÑ PROCESAR AS√çNCRONO", type="primary", use_container_width=True):
                        self.process_async(df, file_data)
                else:
                    st.button("üîÑ As√≠ncrono No Disponible", disabled=True, use_container_width=True, help=async_message)
            
            with col3:
                if st.button("‚ùå Cancelar"):
                    del st.session_state.file_ready_for_processing
                    st.rerun()
            
            # Mostrar ventajas/desventajas
            with st.expander("‚ÑπÔ∏è Comparaci√≥n de Modos"):
                col1, col2 = st.columns(2)
                
                with col1:
                    st.markdown("""
                    **‚ö° Modo S√≠ncrono:**
                    - ‚úÖ Inmediato
                    - ‚úÖ Familiar
                    - ‚úÖ Resultados al instante
                    - ‚ùå Bloquea la interfaz
                    - ‚ùå Lento para archivos grandes
                    """)
                
                with col2:
                    st.markdown("""
                    **üîÑ Modo As√≠ncrono:**
                    - ‚úÖ No bloquea la interfaz
                    - ‚úÖ Progreso en tiempo real
                    - ‚úÖ Puedes hacer otras cosas
                    - ‚ùå Setup inicial
                    - ‚ùå Resultados no inmediatos
                    """)
        
        except Exception as e:
            st.error(f"‚ùå Error analizando archivo: {str(e)}")
            del st.session_state.file_ready_for_processing

    def process_sync(self, df, file_data):
        """Procesar en modo s√≠ncrono REAL en el sistema h√≠brido"""
    
        st.info("‚ö° Procesando en modo S√çNCRONO...")
        
        try:
            # Importar el sistema principal para procesamiento
            from sistema_completo_normalizacion import SistemaNormalizacion
            
            # Crear instancia del sistema principal
            sistema_principal = SistemaNormalizacion()
            
            # Crear barra de progreso
            progress_bar = st.progress(0)
            status_text = st.empty()
            
            # PASO 1: Validar estructura
            status_text.text("üîç Validando estructura del archivo...")
            progress_bar.progress(10)
            
            valido, mensaje = sistema_principal.validar_estructura_archivo(df, file_data['tipo_catalogo'])
            
            if not valido:
                st.error(f"‚ùå Validaci√≥n fall√≥: {mensaje}")
                del st.session_state.file_ready_for_processing
                return
            
            st.success(f"‚úÖ {mensaje}")
            progress_bar.progress(30)
            
            # PASO 2: Procesar archivo
            status_text.text("‚öôÔ∏è Procesando archivo con sistema principal...")
            progress_bar.progress(50)
            
            exito, mensaje_proceso = sistema_principal.procesar_archivo_cargado(
                df, 
                file_data['tipo_catalogo'], 
                file_data['division'], 
                file_data['file'].name
            )
            
            progress_bar.progress(90)
            
            # PASO 3: Mostrar resultado
            if exito:
                progress_bar.progress(100)
                status_text.text("‚úÖ Procesamiento completado")
                
                st.success(f"üéâ ¬°Procesamiento s√≠ncrono exitoso!")
                st.success(f"üìä {mensaje_proceso}")
                
                # Mostrar estad√≠sticas del procesamiento
                col1, col2, col3 = st.columns(3)
                
                with col1:
                    st.metric("üìÑ Archivo", file_data['file'].name)
                with col2:
                    st.metric("üìä Registros", f"{len(df):,}")
                with col3:
                    st.metric("üìã Tipo", file_data['tipo_catalogo'])
                
                # Botones de acci√≥n
                col1, col2, col3 = st.columns(3)
                
                with col1:
                    if st.button("üìã Ver Resultados", type="primary"):
                        st.info("üí° Ve a la pesta√±a 'Resultados' para ver los datos procesados")
                
                with col2:
                    if st.button("üì• Descargar", type="secondary"):
                        st.info("üí° Los resultados est√°n disponibles en la secci√≥n de Resultados")
                
                with col3:
                    if st.button("üìÅ Procesar Otro Archivo"):
                        # Limpiar y permitir subir otro archivo
                        del st.session_state.file_ready_for_processing
                        st.rerun()
                
                # Mostrar informaci√≥n adicional
                with st.expander("‚ÑπÔ∏è Detalles del Procesamiento"):
                    st.markdown(f"""
                    **üìã Informaci√≥n del procesamiento:**
                    - **Modo:** S√≠ncrono (inmediato)
                    - **Archivo:** {file_data['file'].name}
                    - **Tipo:** {file_data['tipo_catalogo']}
                    - **Divisi√≥n:** {file_data['division']}
                    - **Registros:** {len(df):,}
                    - **Usuario:** {file_data['user_id']}
                    - **Fecha:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
                    
                    **‚úÖ El archivo ha sido procesado y los resultados est√°n guardados en la base de datos.**
                    """)
            
            else:
                st.error(f"‚ùå Error en procesamiento: {mensaje_proceso}")
                
                # Mostrar detalles del error
                with st.expander("üîß Detalles del Error"):
                    st.code(f"""
    Archivo: {file_data['file'].name}
    Tipo: {file_data['tipo_catalogo']}
    Divisi√≥n: {file_data['division']}
    Registros: {len(df):,}
    Error: {mensaje_proceso}
                    """)
                
                # Opci√≥n de reintentar
                if st.button("üîÑ Reintentar"):
                    st.rerun()
            
            # Limpiar datos del archivo procesado
            time.sleep(2)
            del st.session_state.file_ready_for_processing
            
        except Exception as e:
            st.error(f"‚ùå Error inesperado en procesamiento s√≠ncrono: {str(e)}")
            
            # Mostrar detalles t√©cnicos
            with st.expander("üîß Informaci√≥n T√©cnica"):
                import traceback
                st.code(traceback.format_exc())
            
            # Limpiar datos
            if 'file_ready_for_processing' in st.session_state:
                del st.session_state.file_ready_for_processing
            
            # Opci√≥n de usar sistema as√≠ncrono como alternativa
            st.markdown("### üí° Alternativa")
            st.info("Si el procesamiento s√≠ncrono falla, puedes intentar con el modo as√≠ncrono")
            
            if st.button("üîÑ Intentar Modo As√≠ncrono"):
                self.process_async(df, file_data)

    def process_async(self, df, file_data):
        """Procesar en modo as√≠ncrono"""
        
        if not self.async_processor:
            st.error("‚ùå Procesador as√≠ncrono no disponible")
            return
        
        st.info("üîÑ Enviando al procesador as√≠ncrono...")
        
        with st.spinner("Preparando tarea..."):
            success, message = self.async_processor.submit_task(
                file_data=df,
                file_name=file_data['file'].name,
                tipo_catalogo=file_data['tipo_catalogo'],
                division=file_data['division'],
                user_id=file_data['user_id'],
                user_role=file_data['user_role']
            )
        
        if success:
            st.success(f"‚úÖ {message}")
            st.info("üìä Ve a la pesta√±a 'Mis Tareas' para ver el progreso")
            
            # Limpiar datos y refrescar
            del st.session_state.file_ready_for_processing
            time.sleep(2)
            st.rerun()
        else:
            st.error(f"‚ùå {message}")
    
    def process_uploaded_file(self, uploaded_file, tipo_catalogo, division, user_id, user_role):
        """Procesar archivo subido y determinar modo de procesamiento"""
    
        try:
            # Leer archivo
            df = pd.read_csv(uploaded_file)
            num_records = len(df)
            
            st.success(f"‚úÖ Archivo le√≠do: {num_records:,} registros")
            
            # Mostrar informaci√≥n del archivo
            col1, col2, col3 = st.columns(3)
            
            with col1:
                st.metric("üìä Registros", f"{num_records:,}")
            
            with col2:
                estimated_time = AsyncUtils.estimate_processing_time(num_records, tipo_catalogo)
                st.metric("‚è±Ô∏è Tiempo Estimado", AsyncUtils.format_duration(estimated_time))
            
            with col3:
                # Determinar modo recomendado
                if num_records >= AsyncConfig.AUTO_ASYNC_THRESHOLD:
                    modo_recomendado = "üîÑ As√≠ncrono"
                    color = "üü¢"
                else:
                    modo_recomendado = "‚ö° S√≠ncrono"
                    color = "üîµ"
                
                st.metric("üéØ Modo Recomendado", f"{color} {modo_recomendado}")
            
            # Opciones de procesamiento FUERA del form
            st.markdown("---")
            st.markdown("### üöÄ Opciones de Procesamiento")
            
            col1, col2 = st.columns(2)
            
            with col1:
                # Modo s√≠ncrono
                st.markdown("#### ‚ö° Procesamiento S√≠ncrono")
                st.markdown("""
                **Ventajas:**
                - ‚úÖ Inmediato
                - ‚úÖ Familiar
                - ‚úÖ Resultados al instante
                
                **Desventajas:**
                - ‚ùå Bloquea la interfaz
                - ‚ùå Lento para archivos grandes
                """)
                
                # BOT√ìN FUERA DEL FORM
                if st.button("‚ö° Procesar S√çNCRONO", type="secondary", use_container_width=True, key=f"sync_{hash(uploaded_file.name)}"):
                    self.process_sync(df, tipo_catalogo, division, uploaded_file.name)
            
            with col2:
                # Modo as√≠ncrono
                st.markdown("#### üîÑ Procesamiento As√≠ncrono")
                st.markdown("""
                **Ventajas:**
                - ‚úÖ No bloquea la interfaz
                - ‚úÖ Progreso en tiempo real
                - ‚úÖ Puedes hacer otras cosas
                
                **Desventajas:**
                - ‚ùå Toma m√°s tiempo en configurar
                - ‚ùå Resultados no inmediatos
                """)
                
                # Validar si puede usar as√≠ncrono
                can_async, async_message = AsyncUtils.validate_file_for_async(df, tipo_catalogo, user_role)
                
                if can_async:
                    # BOT√ìN FUERA DEL FORM
                    if st.button("üîÑ Procesar AS√çNCRONO", type="primary", use_container_width=True, key=f"async_{hash(uploaded_file.name)}"):
                        self.process_async(df, tipo_catalogo, division, uploaded_file.name, user_id, user_role)
                else:
                    st.error(f"‚ùå No disponible: {async_message}")
                    st.button("üîÑ As√≠ncrono No Disponible", disabled=True, use_container_width=True, key=f"async_disabled_{hash(uploaded_file.name)}")
        
        except Exception as e:
            st.error(f"‚ùå Error procesando archivo: {str(e)}")
    

            st.error(f"‚ùå {message}")
    
    def show_async_monitoring(self):
        """Mostrar monitoreo del sistema as√≠ncrono"""
        
        st.markdown("### üìä Monitoreo del Sistema As√≠ncrono")
        
        if not self.async_processor:
            st.error("‚ùå Procesador as√≠ncrono no disponible")
            return
        
        # Estad√≠sticas generales
        stats = self.async_processor.get_system_stats()
        
        col1, col2, col3, col4 = st.columns(4)
        
        with col1:
            st.metric("üîÑ Workers Activos", f"{stats['workers_active']}/{stats['workers_max']}")
        
        with col2:
            st.metric("üìã Tareas Pendientes", stats['total_pending'])
        
        with col3:
            st.metric("‚úÖ Completadas", stats['stats']['total_processed'])
        
        with col4:
            st.metric("‚ùå Fallidas", stats['stats']['total_failed'])
        
        # Estado por prioridad
        st.markdown("#### üìä Colas por Prioridad")
        
        col1, col2, col3 = st.columns(3)
        
        with col1:
            st.metric(
                "üî¥ Alta (SUPERUSUARIO)", 
                stats['pending_by_priority']['high'],
                help="Tareas de usuarios con rol SUPERUSUARIO"
            )
        
        with col2:
            st.metric(
                "üü° Media (GERENTE)", 
                stats['pending_by_priority']['normal'],
                help="Tareas de usuarios con rol GERENTE"
            )
        
        with col3:
            st.metric(
                "üü¢ Normal (USUARIO)", 
                stats['pending_by_priority']['low'],
                help="Tareas de usuarios con rol USUARIO"
            )
        
        # Auto-refresh
        if st.button("üîÑ Actualizar"):
            st.rerun()
        
        # Auto-refresh autom√°tico cada 5 segundos si hay tareas pendientes
        if stats['total_pending'] > 0:
            st.info("üîÑ Actualizando autom√°ticamente cada 5 segundos...")
            time.sleep(5)
            st.rerun()
    
    def show_user_tasks(self):
        """Mostrar tareas del usuario actual - CON BOTONES DE RESULTADOS"""
    
        st.markdown("### üìã Mis Tareas")
        
        usuario_actual = st.session_state.get('usuario_actual', {})
        if not usuario_actual:
            st.error("‚ùå No hay usuario autenticado")
            return
        
        if not self.async_processor:
            st.error("‚ùå Procesador as√≠ncrono no disponible")
            return
        
        user_id = usuario_actual.get('id_usuario', 'unknown')
        user_tasks = self.async_processor.get_user_tasks(user_id)
        
        if not user_tasks:
            st.info("üìù No tienes tareas as√≠ncronas")
            
            # Sugerencia para el usuario
            st.markdown("### üí° ¬øQu√© puedes hacer?")
            col1, col2 = st.columns(2)
            
            with col1:
                st.info("""
                **üì§ Subir Archivos:**
                - Ve a la pesta√±a "Subir Archivos"
                - Selecciona archivos > 5,000 registros
                - Se procesar√°n autom√°ticamente en modo as√≠ncrono
                """)
            
            with col2:
                st.info("""
                **üìä Ver Resultados Anteriores:**
                - Ve a la pesta√±a "Ver Resultados"
                - Consulta archivos procesados previamente
                - Descarga resultados ya completados
                """)
            return
        
        st.success(f"üìä Tienes {len(user_tasks)} tareas")
        
        # Clasificar tareas por estado
        tareas_pendientes = [t for t in user_tasks if t.status in ['PENDING', 'PROCESSING']]
        tareas_completadas = [t for t in user_tasks if t.status == 'SUCCESS']
        tareas_fallidas = [t for t in user_tasks if t.status == 'FAILURE']
        
        # Mostrar resumen
        col1, col2, col3 = st.columns(3)
        
        with col1:
            st.metric("üîÑ En Progreso", len(tareas_pendientes))
        with col2:
            st.metric("‚úÖ Completadas", len(tareas_completadas))
        with col3:
            st.metric("‚ùå Fallidas", len(tareas_fallidas))
        
        # Mostrar cada tarea ordenada por fecha
        todas_tareas = sorted(user_tasks, key=lambda x: x.created_at, reverse=True)
        
        for task in todas_tareas:
            
            # Determinar color y emoji seg√∫n estado
            if task.status == 'SUCCESS':
                status_color = "üü¢"
                status_emoji = "‚úÖ"
            elif task.status == 'FAILURE':
                status_color = "üî¥"
                status_emoji = "‚ùå"
            elif task.status == 'PROCESSING':
                status_color = "üü°"
                status_emoji = "üîÑ"
            else:
                status_color = "‚ö™"
                status_emoji = "‚è≥"
            
            # Expandir autom√°ticamente tareas en progreso y fallidas
            expand_task = task.status in ['PROCESSING', 'FAILURE']
            
            with st.expander(
                f"{status_color} {task.file_name} - {status_emoji} {task.status}", 
                expanded=expand_task
            ):
                
                col1, col2 = st.columns(2)
                
                with col1:
                    st.write(f"**üìÑ Archivo:** {task.file_name}")
                    st.write(f"**üìã Tipo:** {task.tipo_catalogo}")
                    st.write(f"**üè¢ Divisi√≥n:** {task.division}")
                    st.write(f"**üìä Registros:** {task.num_records:,}")
                
                with col2:
                    st.write(f"**üÜî Task ID:** {task.task_id}")
                    st.write(f"**üìÖ Creado:** {task.created_at.strftime('%Y-%m-%d %H:%M:%S')}")
                    st.write(f"**‚è±Ô∏è Estimado:** {AsyncUtils.format_duration(task.estimated_duration)}")
                    
                    if task.error_message:
                        st.error(f"**‚ùå Error:** {task.error_message}")
                
                # Barra de progreso
                progress_value = task.progress / 100.0
                st.progress(progress_value)
                st.write(f"**Progreso:** {task.progress:.1f}%")
                
                # ========================================
                # NUEVA SECCI√ìN: BOTONES DE ACCI√ìN POR ESTADO
                # ========================================
                
                st.markdown("---")
                
                if task.status == 'SUCCESS':
                    # TAREA COMPLETADA - BOTONES DE RESULTADOS
                    self.mostrar_botones_tarea_completada(task)
                    
                elif task.status == 'PROCESSING':
                    # TAREA EN PROGRESO - BOTONES DE MONITOREO
                    self.mostrar_botones_tarea_en_progreso(task)
                    
                elif task.status == 'FAILURE':
                    # TAREA FALLIDA - BOTONES DE SOLUCI√ìN
                    self.mostrar_botones_tarea_fallida(task)
                    
                else:
                    # TAREA PENDIENTE - INFORMACI√ìN
                    st.info("‚è≥ Tarea en cola. Se procesar√° pronto...")
        
        # Auto-refresh si hay tareas en progreso
        if tareas_pendientes:
            st.markdown("---")
            col1, col2 = st.columns([3, 1])
            
            with col1:
                st.info(f"üîÑ Tienes {len(tareas_pendientes)} tareas en progreso. La p√°gina se actualiza autom√°ticamente cada 10 segundos.")
            
            with col2:
                if st.button("üîÑ Actualizar Ahora"):
                    st.rerun()
            
            # Auto-refresh autom√°tico
            time.sleep(10)
            st.rerun()
    
    def show_async_configuration(self):
        """Mostrar y permitir cambiar configuraci√≥n as√≠ncrona"""
        
        st.markdown("### ‚öôÔ∏è Configuraci√≥n del Sistema As√≠ncrono")
        
        # Mostrar configuraci√≥n actual
        st.markdown("#### üìä Configuraci√≥n Actual")
        
        config_info = f"""
        **üéØ Umbral As√≠ncrono:** {AsyncConfig.AUTO_ASYNC_THRESHOLD:,} registros
        **üë• Workers M√°ximos:** {AsyncConfig.MAX_WORKERS}
        **‚è±Ô∏è Timeout:** {AsyncConfig.TASK_TIMEOUT_MINUTES} minutos
        **üßπ Cleanup:** {AsyncConfig.CLEANUP_DAYS} d√≠as
        **üîß Ambiente:** {'Local' if AsyncConfig.is_development() else 'Railway'}
        """
        
        st.info(config_info)
        
        # Configuraciones r√°pidas
        st.markdown("#### ‚ö° Configuraciones R√°pidas")
        
        col1, col2, col3 = st.columns(3)
        
        with col1:
            if st.button("üß™ Desarrollo", help="Configuraci√≥n para testing"):
                AsyncConfig.AUTO_ASYNC_THRESHOLD = 100
                AsyncConfig.MAX_WORKERS = 2
                st.success("‚úÖ Configuraci√≥n de desarrollo aplicada")
                st.rerun()
        
        with col2:
            if st.button("üè¢ Producci√≥n Peque√±a", help="Para pocos usuarios"):
                AsyncConfig.AUTO_ASYNC_THRESHOLD = 2000
                AsyncConfig.MAX_WORKERS = 4
                st.success("‚úÖ Configuraci√≥n de producci√≥n peque√±a aplicada")
                st.rerun()
        
        with col3:
            if st.button("üöÄ Producci√≥n Grande", help="Para muchos usuarios"):
                AsyncConfig.AUTO_ASYNC_THRESHOLD = 5000
                AsyncConfig.MAX_WORKERS = 8
                st.success("‚úÖ Configuraci√≥n de producci√≥n grande aplicada")
                st.rerun()
        
        # Mostrar l√≠mites por rol
        st.markdown("#### üë• L√≠mites por Rol de Usuario")
        
        for role, limits in AsyncConfig.USER_LIMITS.items():
            with st.expander(f"üë§ {role}"):
                # Preparar textos sin f-strings complejos
                if limits['max_files_in_queue'] == -1:
                    archivos_texto = "Ilimitados"
                else:
                    archivos_texto = str(limits['max_files_in_queue'])
                
                if limits['max_records_per_file'] == -1:
                    registros_texto = "Ilimitados"
                else:
                    registros_texto = f"{limits['max_records_per_file']:,}"
                
                st.write(f"**üìÅ Archivos en cola:** {archivos_texto}")
                st.write(f"**üìä Registros por archivo:** {registros_texto}")
                st.write(f"**‚≠ê Prioridad:** {limits['priority']}")

# Funci√≥n para usar en el sistema principal
def show_unified_dashboard():
    """Funci√≥n principal para mostrar el dashboard unificado"""
    
    # Verificar autenticaci√≥n
    if not st.session_state.get('usuario_autenticado', False):
        st.error("‚ùå Debes estar autenticado para usar el sistema as√≠ncrono")
        return
    
    # Crear y mostrar dashboard
    dashboard = UnifiedDashboard()
    dashboard.show_main_interface()


#RRV01

# ========================================
# NUEVAS FUNCIONES PARA BOTONES POR ESTADO
# ========================================

def mostrar_botones_tarea_completada(self, task):
    """Botones para tareas completadas exitosamente"""
    
    st.success("üéâ **¬°Tarea completada exitosamente!**")
    
    col1, col2, col3, col4 = st.columns(4)
    
    with col1:
        # BOT√ìN PRINCIPAL: VER RESULTADOS
        if st.button(
            "üëÅÔ∏è Ver Resultados", 
            key=f"view_results_{task.task_id}",
            type="primary",
            use_container_width=True
        ):
            # Cambiar a la pesta√±a de resultados y mostrar este archivo
            st.session_state[f'show_results_for_{task.task_id}'] = True
            st.success("‚úÖ Mostrando resultados...")
            
            # Simular cambio a tab de resultados
            self.mostrar_resultados_tarea_especifica(task)
    
    with col2:
        # BOT√ìN: DESCARGAR RESULTADOS
        if st.button(
            "üì• Descargar", 
            key=f"download_{task.task_id}",
            use_container_width=True
        ):
            self.descargar_resultados_tarea(task)
    
    with col3:
        # BOT√ìN: ESTAD√çSTICAS
        if st.button(
            "üìä Estad√≠sticas", 
            key=f"stats_{task.task_id}",
            use_container_width=True
        ):
            self.mostrar_estadisticas_tarea(task)
    
    with col4:
        # BOT√ìN: COMPARTIR/EXPORTAR
        if st.button(
            "üì§ Exportar", 
            key=f"export_{task.task_id}",
            use_container_width=True
        ):
            self.exportar_tarea_completa(task)
    
    # Mostrar informaci√≥n de √©xito
    tiempo_transcurrido = (datetime.now() - task.created_at).total_seconds()
    st.info(f"""
    ‚ö° **Procesamiento completado:**
    - üìä **Registros procesados:** {task.num_records:,}
    - ‚è±Ô∏è **Tiempo total:** {AsyncUtils.format_duration(int(tiempo_transcurrido))}
    - üéØ **Progreso:** {task.progress:.1f}%
    """)

def mostrar_botones_tarea_en_progreso(self, task):
    """Botones para tareas en progreso"""
    
    st.info("üîÑ **Tarea en procesamiento...**")
    
    col1, col2, col3 = st.columns(3)
    
    with col1:
        # BOT√ìN: MONITOREAR PROGRESO
        if st.button(
            "üìä Ver Progreso Detallado", 
            key=f"monitor_{task.task_id}",
            type="primary",
            use_container_width=True
        ):
            self.mostrar_progreso_detallado(task)
    
    with col2:
        # BOT√ìN: REFRESCAR ESTADO
        if st.button(
            "üîÑ Actualizar Estado", 
            key=f"refresh_{task.task_id}",
            use_container_width=True
        ):
            st.rerun()
    
    with col3:
        # BOT√ìN: CANCELAR (si es posible)
        if st.button(
            "üõë Cancelar", 
            key=f"cancel_{task.task_id}",
            use_container_width=True
        ):
            if st.session_state.get(f'confirm_cancel_{task.task_id}', False):
                self.cancelar_tarea(task)
            else:
                st.session_state[f'confirm_cancel_{task.task_id}'] = True
                st.warning("‚ö†Ô∏è Haz clic de nuevo para confirmar cancelaci√≥n")
    
    # Informaci√≥n en tiempo real
    tiempo_transcurrido = (datetime.now() - task.created_at).total_seconds()
    tiempo_estimado_restante = task.estimated_duration - tiempo_transcurrido
    
    if tiempo_estimado_restante > 0:
        st.info(f"""
        ‚è±Ô∏è **Estado actual:**
        - üîÑ **Progreso:** {task.progress:.1f}%
        - ‚è∞ **Tiempo transcurrido:** {AsyncUtils.format_duration(int(tiempo_transcurrido))}
        - üìÖ **Tiempo estimado restante:** {AsyncUtils.format_duration(int(tiempo_estimado_restante))}
        """)
    else:
        st.warning("‚ö†Ô∏è La tarea est√° tomando m√°s tiempo del estimado. Esto es normal para archivos grandes.")

def mostrar_botones_tarea_fallida(self, task):
    """Botones para tareas fallidas"""
    
    st.error("‚ùå **Tarea fall√≥ durante el procesamiento**")
    
    col1, col2, col3 = st.columns(3)
    
    with col1:
        # BOT√ìN: VER DETALLES DEL ERROR
        if st.button(
            "üîç Ver Error Detallado", 
            key=f"error_details_{task.task_id}",
            type="primary",
            use_container_width=True
        ):
            self.mostrar_detalles_error(task)
    
    with col2:
        # BOT√ìN: REINTENTAR
        if st.button(
            "üîÑ Reintentar", 
            key=f"retry_{task.task_id}",
            use_container_width=True
        ):
            self.reintentar_tarea(task)
    
    with col3:
        # BOT√ìN: REPORTAR ERROR
        if st.button(
            "üìß Reportar Error", 
            key=f"report_{task.task_id}",
            use_container_width=True
        ):
            self.reportar_error_tarea(task)
    
    # Mostrar informaci√≥n del error
    if task.error_message:
        with st.expander("üîß Detalles del Error"):
            st.code(f"""
Error: {task.error_message}
Archivo: {task.file_name}
Tipo: {task.tipo_catalogo}
Registros: {task.num_records:,}
Progreso alcanzado: {task.progress:.1f}%
Fecha de fallo: {task.created_at.strftime('%Y-%m-%d %H:%M:%S')}
            """)

# ========================================
# FUNCIONES DE SOPORTE PARA LOS BOTONES
# ========================================

def mostrar_resultados_tarea_especifica(self, task):
    """Mostrar resultados espec√≠ficos de una tarea completada"""
    
    st.markdown("---")
    st.markdown(f"### üìä Resultados: {task.file_name}")
    
    # Buscar el id_archivo asociado a esta tarea
    try:
        from sistema_completo_normalizacion import SistemaNormalizacion
        sistema = SistemaNormalizacion()
        
        with sistema.engine.connect() as conn:
            # Buscar archivo por task_id o nombre + fecha
            result = conn.execute(text("""
                SELECT id_archivo FROM archivos_cargados 
                WHERE task_id = :task_id 
                   OR (nombre_archivo = :filename 
                       AND DATE(fecha_carga) = DATE(:fecha))
                ORDER BY fecha_carga DESC
                LIMIT 1
            """), {
                'task_id': task.task_id,
                'filename': task.file_name,
                'fecha': task.created_at.date()
            })
            
            archivo_row = result.fetchone()
            
            if archivo_row:
                id_archivo = archivo_row[0]
                
                # Mostrar resultados del archivo
                from sistema_completo_normalizacion import mostrar_resultados_archivo
                mostrar_resultados_archivo(id_archivo)
            else:
                st.error("‚ùå No se encontraron resultados para esta tarea")
                st.info("üí° Los resultados pueden estar en la pesta√±a 'Ver Resultados'")
    
    except Exception as e:
        st.error(f"Error mostrando resultados: {str(e)}")

def descargar_resultados_tarea(self, task):
    """Descargar resultados de una tarea espec√≠fica"""
    
    try:
        from sistema_completo_normalizacion import SistemaNormalizacion
        sistema = SistemaNormalizacion()
        
        with sistema.engine.connect() as conn:
            # Buscar archivo asociado
            result = conn.execute(text("""
                SELECT id_archivo FROM archivos_cargados 
                WHERE task_id = :task_id 
                   OR (nombre_archivo = :filename 
                       AND DATE(fecha_carga) = DATE(:fecha))
                ORDER BY fecha_carga DESC
                LIMIT 1
            """), {
                'task_id': task.task_id,
                'filename': task.file_name,
                'fecha': task.created_at.date()
            })
            
            archivo_row = result.fetchone()
            
            if archivo_row:
                id_archivo = archivo_row[0]
                
                # Usar funci√≥n existente de descarga
                from sistema_completo_normalizacion import descargar_resultados_archivo
                descargar_resultados_archivo(id_archivo)
            else:
                st.error("‚ùå No se encontraron resultados para descargar")
    
    except Exception as e:
        st.error(f"Error preparando descarga: {str(e)}")

def mostrar_estadisticas_tarea(self, task):
    """Mostrar estad√≠sticas espec√≠ficas de una tarea"""
    
    st.markdown("---")
    st.markdown(f"### üìä Estad√≠sticas: {task.file_name}")
    
    try:
        from sistema_completo_normalizacion import SistemaNormalizacion
        sistema = SistemaNormalizacion()
        
        with sistema.engine.connect() as conn:
            result = conn.execute(text("""
                SELECT 
                    COUNT(*) as total_procesados,
                    COUNT(CASE WHEN valor_normalizado IS NOT NULL THEN 1 END) as exitosos,
                    COUNT(CASE WHEN requiere_revision = true THEN 1 END) as revision,
                    AVG(CASE WHEN confianza > 0 THEN confianza END) as confianza_promedio,
                    COUNT(DISTINCT metodo_usado) as metodos_usados
                FROM resultados_normalizacion r
                JOIN archivos_cargados a ON r.id_archivo = a.id_archivo
                WHERE a.task_id = :task_id 
                   OR (a.nombre_archivo = :filename 
                       AND DATE(a.fecha_carga) = DATE(:fecha))
            """), {
                'task_id': task.task_id,
                'filename': task.file_name,
                'fecha': task.created_at.date()
            })
            
            stats_row = result.fetchone()
            
            if stats_row:
                stats = dict(stats_row._mapping)
                
                # Mostrar m√©tricas
                col1, col2, col3, col4 = st.columns(4)
                
                with col1:
                    st.metric("üìä Total Procesados", f"{stats['total_procesados']:,}")
                
                with col2:
                    exitosos = stats['exitosos'] or 0
                    total = stats['total_procesados'] or 1
                    porcentaje = (exitosos / total * 100) if total > 0 else 0
                    st.metric("‚úÖ Exitosos", f"{exitosos:,}", f"{porcentaje:.1f}%")
                
                with col3:
                    st.metric("‚ö†Ô∏è Requieren Revisi√≥n", f"{stats['revision'] or 0:,}")
                
                with col4:
                    confianza = stats['confianza_promedio'] or 0
                    st.metric("üéØ Confianza Promedio", f"{confianza:.1%}" if confianza > 0 else "N/A")
                
                # Informaci√≥n adicional
                tiempo_total = (datetime.now() - task.created_at).total_seconds()
                
                st.info(f"""
                **üìã Resumen del Procesamiento:**
                - **Archivo:** {task.file_name}
                - **Tipo:** {task.tipo_catalogo}
                - **Divisi√≥n:** {task.division}
                - **Tiempo total:** {AsyncUtils.format_duration(int(tiempo_total))}
                - **M√©todos usados:** {stats['metodos_usados'] or 0}
                - **Registros por segundo:** {(stats['total_procesados'] or 0) / max(tiempo_total, 1):.1f}
                """)
            else:
                st.warning("‚ö†Ô∏è No se encontraron estad√≠sticas para esta tarea")
    
    except Exception as e:
        st.error(f"Error obteniendo estad√≠sticas: {str(e)}")

def mostrar_progreso_detallado(self, task):
    """Mostrar progreso detallado de una tarea en ejecuci√≥n"""
    
    st.markdown("---")
    st.markdown(f"### üîÑ Progreso Detallado: {task.file_name}")
    
    # Calcular m√©tricas en tiempo real
    tiempo_transcurrido = (datetime.now() - task.created_at).total_seconds()
    progreso_pct = task.progress / 100.0
    
    # Estimaciones
    if progreso_pct > 0:
        tiempo_total_estimado = tiempo_transcurrido / progreso_pct
        tiempo_restante = tiempo_total_estimado - tiempo_transcurrido
        registros_por_segundo = (task.num_records * progreso_pct) / tiempo_transcurrido
    else:
        tiempo_restante = task.estimated_duration
        registros_por_segundo = 0
    
    # Mostrar m√©tricas de progreso
    col1, col2, col3 = st.columns(3)
    
    with col1:
        st.metric("‚è±Ô∏è Tiempo Transcurrido", AsyncUtils.format_duration(int(tiempo_transcurrido)))
        st.metric("üìä Registros Estimados Procesados", f"{int(task.num_records * progreso_pct):,}")
    
    with col2:
        st.metric("‚è∞ Tiempo Restante Estimado", AsyncUtils.format_duration(int(max(tiempo_restante, 0))))
        st.metric("‚ö° Velocidad", f"{registros_por_segundo:.1f} reg/seg")
    
    with col3:
        st.metric("üéØ Progreso", f"{task.progress:.1f}%")
        st.metric("üìà ETA", (datetime.now() + timedelta(seconds=max(tiempo_restante, 0))).strftime('%H:%M:%S'))
    
    # Barra de progreso visual mejorada
    st.progress(progreso_pct)
    
    # Informaci√≥n adicional
    st.info(f"""
    **üìã Detalles del Procesamiento:**
    - **Task ID:** {task.task_id}
    - **Archivo:** {task.file_name}
    - **Total de registros:** {task.num_records:,}
    - **Iniciado:** {task.created_at.strftime('%Y-%m-%d %H:%M:%S')}
    - **Prioridad:** {'Alta' if hasattr(task, 'priority') and task.priority >= 3 else 'Normal'}
    """)

def cancelar_tarea(self, task):
    """Cancelar una tarea en progreso"""
    
    try:
        # Aqu√≠ implementar√≠as la l√≥gica para cancelar la tarea
        # Esto depender√≠a de c√≥mo est√© implementado tu sistema de workers
        
        st.warning(f"üõë Cancelando tarea: {task.file_name}")
        
        # Simular cancelaci√≥n (implementar seg√∫n tu sistema)
        # self.async_processor.cancel_task(task.task_id)
        
        st.success("‚úÖ Tarea cancelada exitosamente")
        st.info("üîÑ Actualizando lista de tareas...")
        
        time.sleep(2)
        st.rerun()
        
    except Exception as e:
        st.error(f"‚ùå Error cancelando tarea: {str(e)}")

def mostrar_detalles_error(self, task):
    """Mostrar detalles completos del error"""
    
    st.markdown("---")
    st.markdown(f"### üîç An√°lisis de Error: {task.file_name}")
    
    # Informaci√≥n b√°sica del error
    col1, col2 = st.columns(2)
    
    with col1:
        st.error("**Error Principal:**")
        st.code(task.error_message or "Error sin mensaje espec√≠fico")
    
    with col2:
        st.info("**Informaci√≥n de la Tarea:**")
        st.write(f"- **Archivo:** {task.file_name}")
        st.write(f"- **Tipo:** {task.tipo_catalogo}")
        st.write(f"- **Registros:** {task.num_records:,}")
        st.write(f"- **Progreso alcanzado:** {task.progress:.1f}%")
    
    # Sugerencias de soluci√≥n
    st.markdown("### üí° Posibles Soluciones:")
    
    if "timeout" in (task.error_message or "").lower():
        st.warning("""
        **‚è±Ô∏è Error de Timeout:**
        - El archivo es muy grande para el tiempo l√≠mite
        - **Soluci√≥n:** Intenta dividir el archivo en partes m√°s peque√±as
        - **O:** Procesa en horario de menor carga
        """)
    
    elif "memory" in (task.error_message or "").lower():
        st.warning("""
        **üíæ Error de Memoria:**
        - El archivo excede la memoria disponible
        - **Soluci√≥n:** Procesa el archivo por partes
        - **O:** Usa el sistema s√≠ncrono para archivos grandes
        """)
    
    elif "database" in (task.error_message or "").lower():
        st.warning("""
        **üóÑÔ∏è Error de Base de Datos:**
        - Problema de conexi√≥n o espacio en BD
        - **Soluci√≥n:** Reintenta en unos minutos
        - **O:** Contacta al administrador del sistema
        """)
    
    else:
        st.info("""
        **üîß Error General:**
        - Revisa que el archivo tenga el formato correcto
        - Verifica que las columnas sean las esperadas
        - Intenta con el sistema s√≠ncrono como alternativa
        """)

def reintentar_tarea(self, task):
    """Reintentar una tarea fallida"""
    
    st.warning(f"üîÑ Reintentando tarea: {task.file_name}")
    
    try:
        # Aqu√≠ implementar√≠as la l√≥gica para reintentar
        # Esto podr√≠a involucrar volver a encolar la tarea
        
        st.info("üì§ Reencolando tarea para procesamiento...")
        
        # Simular reintento (implementar seg√∫n tu sistema)
        # new_task_id = self.async_processor.retry_task(task.task_id)
        
        st.success("‚úÖ Tarea reencolada exitosamente")
        st.info("üîÑ La tarea aparecer√° como 'PENDING' en la lista")
        
        time.sleep(2)
        st.rerun()
        
    except Exception as e:
        st.error(f"‚ùå Error reintentando tarea: {str(e)}")

def reportar_error_tarea(self, task):
    """Reportar error al administrador"""
    
    st.markdown("---")
    st.markdown(f"### üìß Reportar Error: {task.file_name}")
    
    # Formulario de reporte
    with st.form(f"error_report_{task.task_id}"):
        st.write("**Informaci√≥n que se enviar√° al administrador:**")
        
        descripcion_usuario = st.text_area(
            "Describe qu√© estabas haciendo cuando ocurri√≥ el error:",
            placeholder="Ej: Sub√≠ un archivo de COLONIAS de 15,000 registros y fall√≥ al 80% de progreso..."
        )
        
        incluir_archivo = st.checkbox(
            "Incluir informaci√≥n del archivo en el reporte",
            value=True
        )
        
        email_usuario = st.text_input(
            "Tu email (opcional, para seguimiento):",
            placeholder="usuario@empresa.com"
        )
        
        if st.form_submit_button("üìß Enviar Reporte", type="primary"):
            # Aqu√≠ implementar√≠as el env√≠o del reporte
            reporte_data = {
                'task_id': task.task_id,
                'file_name': task.file_name,
                'error_message': task.error_message,
                'user_description': descripcion_usuario,
                'user_email': email_usuario,
                'include_file_info': incluir_archivo,
                'timestamp': datetime.now()
            }
            
            # Simular env√≠o de reporte
            st.success("‚úÖ Reporte enviado al administrador")
            st.info("üìß Recibir√°s una respuesta en las pr√≥ximas 24 horas")

def exportar_tarea_completa(self, task):
    """Exportar informaci√≥n completa de la tarea"""
    
    try:
        # Crear reporte completo de la tarea
        reporte = f"""
    REPORTE COMPLETO DE TAREA AS√çNCRONA
    ==================================

    INFORMACI√ìN B√ÅSICA:
    - Task ID: {task.task_id}
    - Archivo: {task.file_name}
    - Tipo de Cat√°logo: {task.tipo_catalogo}
    - Divisi√≥n: {task.division}
    - Total de Registros: {task.num_records:,}

    ESTADO:
    - Estado Actual: {task.status}
    - Progreso: {task.progress:.1f}%
    - Fecha de Creaci√≥n: {task.created_at.strftime('%Y-%m-%d %H:%M:%S')}
    - Duraci√≥n Estimada: {AsyncUtils.format_duration(task.estimated_duration)}

    PROCESAMIENTO:
    - Tiempo Transcurrido: {AsyncUtils.format_duration(int((datetime.now() - task.created_at).total_seconds()))}
    - Usuario: {st.session_state.get('usuario_actual', {}).get('username', 'Unknown')}

    ERRORES:
    {task.error_message or 'Ninguno'}

    GENERADO: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
            """
        
        st.download_button(
            label="üì§ Descargar Reporte Completo",
            data=reporte,
            file_name=f"reporte_tarea_{task.task_id}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.txt",
            mime="text/plain",
            key=f"export_report_{task.task_id}"
        )
        
        st.success("‚úÖ Reporte preparado para descarga")
        
    except Exception as e:
        st.error(f"Error generando reporte: {str(e)}")



# Para testing
if __name__ == "__main__":
    # Simular usuario autenticado para testing
    st.session_state.usuario_autenticado = True
    st.session_state.usuario_actual = {
        'id_usuario': 'test_user',
        'username': 'test',
        'rol': 'GERENTE',
        'nombre_completo': 'Usuario de Prueba'
    }
    
    show_unified_dashboard()